{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/ravi/coinflip/coin-flip-test-main/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/ravi/coinflip/coin-flip-test-main/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;\n\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar SafeSignature_1 = __importDefault(require(\"./SafeSignature\"));\n\nfunction generatePreValidatedSignature(ownerAddress) {\n  var signature = '0x000000000000000000000000' + ownerAddress.slice(2) + '0000000000000000000000000000000000000000000000000000000000000000' + '01';\n  return new SafeSignature_1.default(ownerAddress, signature);\n}\n\nexports.generatePreValidatedSignature = generatePreValidatedSignature;\n\nfunction isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {\n  var hasPrefix;\n\n  try {\n    var rsvSig = {\n      r: Buffer.from(signature.slice(2, 66), 'hex'),\n      s: Buffer.from(signature.slice(66, 130), 'hex'),\n      v: parseInt(signature.slice(130, 132), 16)\n    };\n    var recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);\n    var recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));\n    hasPrefix = !(0, utils_1.sameString)(recoveredAddress, ownerAddress);\n  } catch (e) {\n    hasPrefix = true;\n  }\n\n  return hasPrefix;\n}\n\nexports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;\n\nvar adjustVInSignature = function adjustVInSignature(signingMethod, signature, safeTxHash, signerAddress) {\n  var ETHEREUM_V_VALUES = [0, 1, 27, 28];\n  var MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;\n  var signatureV = parseInt(signature.slice(-2), 16);\n\n  if (!ETHEREUM_V_VALUES.includes(signatureV)) {\n    throw new Error('Invalid signature');\n  }\n\n  if (signingMethod === 'eth_sign') {\n    /*\n      The Safe's expected V value for ECDSA signature is:\n      - 27 or 28\n      - 31 or 32 if the message was signed with a EIP-191 prefix. Should be calculated as ECDSA V value + 4\n      Some wallets do that, some wallets don't, V > 30 is used by contracts to differentiate between\n      prefixed and non-prefixed messages. The only way to know if the message was signed with a\n      prefix is to check if the signer address is the same as the recovered address.\n           More info:\n      https://docs.gnosis-safe.io/contracts/signatures\n    */\n    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n    }\n\n    var adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);\n    var signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);\n\n    if (signatureHasPrefix) {\n      signatureV += 4;\n    }\n  }\n\n  if (signingMethod === 'eth_signTypedData') {\n    // Metamask with ledger returns V=0/1 here too, we need to adjust it to be ethereum's valid value (27 or 28)\n    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n    }\n  }\n\n  signature = signature.slice(0, -2) + signatureV.toString(16);\n  return signature;\n};\n\nexports.adjustVInSignature = adjustVInSignature;\n\nfunction generateSignature(_x, _x2) {\n  return _generateSignature.apply(this, arguments);\n}\n\nfunction _generateSignature() {\n  _generateSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ethAdapter, hash) {\n    var signerAddress, signature;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return ethAdapter.getSignerAddress();\n\n          case 2:\n            signerAddress = _context.sent;\n\n            if (signerAddress) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error('EthAdapter must be initialized with a signer to use this method');\n\n          case 5:\n            _context.next = 7;\n            return ethAdapter.signMessage(hash);\n\n          case 7:\n            signature = _context.sent;\n            signature = (0, exports.adjustVInSignature)('eth_sign', signature, hash, signerAddress);\n            return _context.abrupt(\"return\", new SafeSignature_1.default(signerAddress, signature));\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _generateSignature.apply(this, arguments);\n}\n\nexports.generateSignature = generateSignature;\n\nfunction generateEIP712Signature(_x3, _x4, _x5) {\n  return _generateEIP712Signature.apply(this, arguments);\n}\n\nfunction _generateEIP712Signature() {\n  _generateEIP712Signature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ethAdapter, safeTransactionEIP712Args, methodVersion) {\n    var signerAddress, signature;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return ethAdapter.getSignerAddress();\n\n          case 2:\n            signerAddress = _context2.sent;\n\n            if (signerAddress) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error('EthAdapter must be initialized with a signer to use this method');\n\n          case 5:\n            _context2.next = 7;\n            return ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);\n\n          case 7:\n            signature = _context2.sent;\n            signature = (0, exports.adjustVInSignature)('eth_signTypedData', signature);\n            return _context2.abrupt(\"return\", new SafeSignature_1.default(signerAddress, signature));\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _generateEIP712Signature.apply(this, arguments);\n}\n\nexports.generateEIP712Signature = generateEIP712Signature;","map":{"version":3,"sources":["../../../../src/utils/signatures/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst utils_1 = require(\"../../utils\");\nconst SafeSignature_1 = __importDefault(require(\"./SafeSignature\"));\nfunction generatePreValidatedSignature(ownerAddress) {\n    const signature = '0x000000000000000000000000' +\n        ownerAddress.slice(2) +\n        '0000000000000000000000000000000000000000000000000000000000000000' +\n        '01';\n    return new SafeSignature_1.default(ownerAddress, signature);\n}\nexports.generatePreValidatedSignature = generatePreValidatedSignature;\nfunction isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {\n    let hasPrefix;\n    try {\n        const rsvSig = {\n            r: Buffer.from(signature.slice(2, 66), 'hex'),\n            s: Buffer.from(signature.slice(66, 130), 'hex'),\n            v: parseInt(signature.slice(130, 132), 16)\n        };\n        const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);\n        const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));\n        hasPrefix = !(0, utils_1.sameString)(recoveredAddress, ownerAddress);\n    }\n    catch (e) {\n        hasPrefix = true;\n    }\n    return hasPrefix;\n}\nexports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;\nconst adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {\n    const ETHEREUM_V_VALUES = [0, 1, 27, 28];\n    const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;\n    let signatureV = parseInt(signature.slice(-2), 16);\n    if (!ETHEREUM_V_VALUES.includes(signatureV)) {\n        throw new Error('Invalid signature');\n    }\n    if (signingMethod === 'eth_sign') {\n        /*\n          The Safe's expected V value for ECDSA signature is:\n          - 27 or 28\n          - 31 or 32 if the message was signed with a EIP-191 prefix. Should be calculated as ECDSA V value + 4\n          Some wallets do that, some wallets don't, V > 30 is used by contracts to differentiate between\n          prefixed and non-prefixed messages. The only way to know if the message was signed with a\n          prefix is to check if the signer address is the same as the recovered address.\n    \n          More info:\n          https://docs.gnosis-safe.io/contracts/signatures\n        */\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n        }\n        const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);\n        const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);\n        if (signatureHasPrefix) {\n            signatureV += 4;\n        }\n    }\n    if (signingMethod === 'eth_signTypedData') {\n        // Metamask with ledger returns V=0/1 here too, we need to adjust it to be ethereum's valid value (27 or 28)\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n        }\n    }\n    signature = signature.slice(0, -2) + signatureV.toString(16);\n    return signature;\n};\nexports.adjustVInSignature = adjustVInSignature;\nasync function generateSignature(ethAdapter, hash) {\n    const signerAddress = await ethAdapter.getSignerAddress();\n    if (!signerAddress) {\n        throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n    let signature = await ethAdapter.signMessage(hash);\n    signature = (0, exports.adjustVInSignature)('eth_sign', signature, hash, signerAddress);\n    return new SafeSignature_1.default(signerAddress, signature);\n}\nexports.generateSignature = generateSignature;\nasync function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {\n    const signerAddress = await ethAdapter.getSignerAddress();\n    if (!signerAddress) {\n        throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n    let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);\n    signature = (0, exports.adjustVInSignature)('eth_signTypedData', signature);\n    return new SafeSignature_1.default(signerAddress, signature);\n}\nexports.generateEIP712Signature = generateEIP712Signature;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}