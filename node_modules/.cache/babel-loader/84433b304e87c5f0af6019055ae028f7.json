{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _Safe_ethAdapter, _Safe_contractManager, _Safe_ownerManager, _Safe_moduleManager, _Safe_guardManager, _Safe_fallbackHandlerManager;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\n\nconst safe_core_sdk_types_1 = require(\"@safe-global/safe-core-sdk-types\");\n\nconst contractManager_1 = __importDefault(require(\"./managers/contractManager\"));\n\nconst fallbackHandlerManager_1 = __importDefault(require(\"./managers/fallbackHandlerManager\"));\n\nconst guardManager_1 = __importDefault(require(\"./managers/guardManager\"));\n\nconst moduleManager_1 = __importDefault(require(\"./managers/moduleManager\"));\n\nconst ownerManager_1 = __importDefault(require(\"./managers/ownerManager\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst signatures_1 = require(\"./utils/signatures\");\n\nconst SafeSignature_1 = __importDefault(require(\"./utils/signatures/SafeSignature\"));\n\nconst SafeTransaction_1 = __importDefault(require(\"./utils/transactions/SafeTransaction\"));\n\nconst utils_2 = require(\"./utils/transactions/utils\");\n\nclass Safe {\n  constructor() {\n    _Safe_ethAdapter.set(this, void 0);\n\n    _Safe_contractManager.set(this, void 0);\n\n    _Safe_ownerManager.set(this, void 0);\n\n    _Safe_moduleManager.set(this, void 0);\n\n    _Safe_guardManager.set(this, void 0);\n\n    _Safe_fallbackHandlerManager.set(this, void 0);\n  }\n  /**\n   * Creates an instance of the Safe Core SDK.\n   * @param config - Ethers Safe configuration\n   * @returns The Safe Core SDK instance\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  static async create(_ref) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref;\n    const safeSdk = new Safe();\n    await safeSdk.init({\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    });\n    return safeSdk;\n  }\n  /**\n   * Initializes the Safe Core SDK instance.\n   * @param config - Safe configuration\n   * @throws \"Signer must be connected to a provider\"\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  async init(_ref2) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref2;\n\n    __classPrivateFieldSet(this, _Safe_ethAdapter, ethAdapter, \"f\");\n\n    __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({\n      ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    }), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n\n    __classPrivateFieldSet(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n  }\n  /**\n   * Returns a new instance of the Safe Core SDK.\n   * @param config - Connect Safe configuration\n   * @throws \"SafeProxy contract is not deployed on the current network\"\n   * @throws \"MultiSend contract is not deployed on the current network\"\n   * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n   */\n\n\n  async connect(_ref3) {\n    let {\n      ethAdapter,\n      safeAddress,\n      isL1SafeMasterCopy,\n      contractNetworks\n    } = _ref3;\n    return await Safe.create({\n      ethAdapter: ethAdapter || __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n      safeAddress: safeAddress || this.getAddress(),\n      isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").isL1SafeMasterCopy,\n      contractNetworks: contractNetworks || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").contractNetworks\n    });\n  }\n  /**\n   * Returns the address of the current SafeProxy contract.\n   *\n   * @returns The address of the SafeProxy contract\n   */\n\n\n  getAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getAddress();\n  }\n  /**\n   * Returns the ContractManager\n   *\n   * @returns The current ContractManager\n   * */\n\n\n  getContractManager() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\");\n  }\n  /**\n   * Returns the current EthAdapter.\n   *\n   * @returns The current EthAdapter\n   */\n\n\n  getEthAdapter() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\");\n  }\n  /**\n   * Returns the address of the MultiSend contract.\n   *\n   * @returns The address of the MultiSend contract\n   */\n\n\n  getMultiSendAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract.getAddress();\n  }\n  /**\n   * Returns the address of the MultiSendCallOnly contract.\n   *\n   * @returns The address of the MultiSendCallOnly contract\n   */\n\n\n  getMultiSendCallOnlyAddress() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract.getAddress();\n  }\n  /**\n   * Returns the Safe Master Copy contract version.\n   *\n   * @returns The Safe Master Copy contract version\n   */\n\n\n  async getContractVersion() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getVersion();\n  }\n  /**\n   * Returns the list of Safe owner accounts.\n   *\n   * @returns The list of owners\n   */\n\n\n  async getOwners() {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getOwners();\n  }\n  /**\n   * Returns the Safe nonce.\n   *\n   * @returns The Safe nonce\n   */\n\n\n  async getNonce() {\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getNonce();\n  }\n  /**\n   * Returns the Safe threshold.\n   *\n   * @returns The Safe threshold\n   */\n\n\n  async getThreshold() {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getThreshold();\n  }\n  /**\n   * Returns the chainId of the connected network.\n   *\n   * @returns The chainId of the connected network\n   */\n\n\n  async getChainId() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getChainId();\n  }\n  /**\n   * Returns the ETH balance of the Safe.\n   *\n   * @returns The ETH balance of the Safe\n   */\n\n\n  async getBalance() {\n    return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getBalance(this.getAddress());\n  }\n  /**\n   * Returns the address of the FallbackHandler contract.\n   *\n   * @returns The address of the FallbackHandler contract\n   */\n\n\n  getFallbackHandler() {\n    return __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").getFallbackHandler();\n  }\n  /**\n   * Returns the enabled Safe guard or 0x address if no guards are enabled.\n   *\n   * @returns The address of the enabled Safe guard\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async getGuard() {\n    return __classPrivateFieldGet(this, _Safe_guardManager, \"f\").getGuard();\n  }\n  /**\n   * Returns the list of addresses of all the enabled Safe modules.\n   *\n   * @returns The list of addresses of all the enabled Safe modules\n   */\n\n\n  async getModules() {\n    return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").getModules();\n  }\n  /**\n   * Checks if a specific Safe module is enabled for the current Safe.\n   *\n   * @param moduleAddress - The desired module address\n   * @returns TRUE if the module is enabled\n   */\n\n\n  async isModuleEnabled(moduleAddress) {\n    return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").isModuleEnabled(moduleAddress);\n  }\n  /**\n   * Checks if a specific address is an owner of the current Safe.\n   *\n   * @param ownerAddress - The account address\n   * @returns TRUE if the account is an owner\n   */\n\n\n  async isOwner(ownerAddress) {\n    return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").isOwner(ownerAddress);\n  }\n  /**\n   * Returns a Safe transaction ready to be signed by the owners.\n   *\n   * @param createTransactionProps - The createTransaction props\n   * @returns The Safe transaction\n   * @throws \"Invalid empty array of transactions\"\n   */\n\n\n  async createTransaction(_ref4) {\n    let {\n      safeTransactionData,\n      onlyCalls = false,\n      options\n    } = _ref4;\n\n    if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {\n      throw new Error('Invalid empty array of transactions');\n    }\n\n    let newTransaction;\n\n    if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {\n      const multiSendContract = onlyCalls ? __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract : __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract;\n      const multiSendData = (0, utils_2.encodeMultiSendData)(safeTransactionData.map(utils_2.standardizeMetaTransactionData));\n      const multiSendTransaction = { ...options,\n        to: multiSendContract.getAddress(),\n        value: '0',\n        data: multiSendContract.encode('multiSend', [multiSendData]),\n        operation: safe_core_sdk_types_1.OperationType.DelegateCall\n      };\n      newTransaction = multiSendTransaction;\n    } else {\n      newTransaction = (0, utils_1.isMetaTransactionArray)(safeTransactionData) ? { ...options,\n        ...safeTransactionData[0]\n      } : safeTransactionData;\n    }\n\n    const standardizedTransaction = await (0, utils_2.standardizeSafeTransactionData)(__classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract, __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), newTransaction);\n    return new SafeTransaction_1.default(standardizedTransaction);\n  }\n  /**\n   * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.\n   *\n   * @param nonce - The nonce of the transaction/s that are going to be rejected\n   * @returns The Safe transaction that invalidates the pending Safe transaction/s\n   */\n\n\n  async createRejectionTransaction(nonce) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      nonce,\n      value: '0',\n      data: '0x',\n      safeTxGas: 0\n    };\n    return this.createTransaction({\n      safeTransactionData\n    });\n  }\n  /**\n   * Copies a Safe transaction\n   *\n   * @param safeTransaction - The Safe transaction\n   * @returns The new Safe transaction\n   */\n\n\n  async copyTransaction(safeTransaction) {\n    const signedSafeTransaction = await this.createTransaction({\n      safeTransactionData: safeTransaction.data\n    });\n    safeTransaction.signatures.forEach(signature => {\n      signedSafeTransaction.addSignature(signature);\n    });\n    return signedSafeTransaction;\n  }\n  /**\n   * Returns the transaction hash of a Safe transaction.\n   *\n   * @param safeTransaction - The Safe transaction\n   * @returns The transaction hash of the Safe transaction\n   */\n\n\n  async getTransactionHash(safeTransaction) {\n    const safeTransactionData = safeTransaction.data;\n    const txHash = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getTransactionHash(safeTransactionData);\n    return txHash;\n  }\n  /**\n   * Signs a hash using the current signer account.\n   *\n   * @param hash - The hash to sign\n   * @returns The Safe signature\n   */\n\n\n  async signTransactionHash(hash) {\n    return (0, signatures_1.generateSignature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), hash);\n  }\n  /**\n   * Signs a transaction according to the EIP-712 using the current signer account.\n   *\n   * @param safeTransaction - The Safe transaction to be signed\n   * @param methodVersion - EIP-712 version. Optional\n   * @returns The Safe signature\n   */\n\n\n  async signTypedData(safeTransaction, methodVersion) {\n    const safeTransactionEIP712Args = {\n      safeAddress: this.getAddress(),\n      safeVersion: await this.getContractVersion(),\n      chainId: await this.getEthAdapter().getChainId(),\n      safeTransactionData: safeTransaction.data\n    };\n    return (0, signatures_1.generateEIP712Signature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), safeTransactionEIP712Args, methodVersion);\n  }\n  /**\n   * Adds the signature of the current signer to the Safe transaction object.\n   *\n   * @param safeTransaction - The Safe transaction to be signed\n   * @param signingMethod - Method followed to sign a transaction. Optional. Default value is \"eth_sign\"\n   * @returns The signed Safe transaction\n   * @throws \"Transactions can only be signed by Safe owners\"\n   */\n\n\n  async signTransaction(safeTransaction) {\n    let signingMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'eth_sign';\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    const addressIsOwner = owners.find(owner => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n\n    if (!addressIsOwner) {\n      throw new Error('Transactions can only be signed by Safe owners');\n    }\n\n    let signature;\n\n    if (signingMethod === 'eth_signTypedData') {\n      signature = await this.signTypedData(transaction);\n    } else {\n      const txHash = await this.getTransactionHash(transaction);\n      signature = await this.signTransactionHash(txHash);\n    }\n\n    const signedSafeTransaction = await this.createTransaction({\n      safeTransactionData: transaction.data\n    });\n    transaction.signatures.forEach(signature => {\n      signedSafeTransaction.addSignature(signature);\n    });\n    signedSafeTransaction.addSignature(signature);\n    return signedSafeTransaction;\n  }\n  /**\n   * Approves on-chain a hash using the current signer account.\n   *\n   * @param hash - The hash to approve\n   * @param options - The Safe transaction execution options. Optional\n   * @returns The Safe transaction response\n   * @throws \"Transaction hashes can only be approved by Safe owners\"\n   * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n   */\n\n\n  async approveTransactionHash(hash, options) {\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    const addressIsOwner = owners.find(owner => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n\n    if (!addressIsOwner) {\n      throw new Error('Transaction hashes can only be approved by Safe owners');\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n      throw new Error('Cannot specify gas and gasLimit together in transaction options');\n    }\n\n    return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approveHash(hash, {\n      from: signerAddress,\n      ...options\n    });\n  }\n  /**\n   * Returns a list of owners who have approved a specific Safe transaction.\n   *\n   * @param txHash - The Safe transaction hash\n   * @returns The list of owners\n   */\n\n\n  async getOwnersWhoApprovedTx(txHash) {\n    const owners = await this.getOwners();\n    let ownersWhoApproved = [];\n\n    for (const owner of owners) {\n      const approved = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approvedHashes(owner, txHash);\n\n      if (approved.gt(0)) {\n        ownersWhoApproved.push(owner);\n      }\n    }\n\n    return ownersWhoApproved;\n  }\n  /**\n   * Returns the Safe transaction to enable the fallback handler.\n   *\n   * @param address - The new fallback handler address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid fallback handler address provided\"\n   * @throws \"Fallback handler provided is already enabled\"\n   * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n   */\n\n\n  async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeEnableFallbackHandlerData(fallbackHandlerAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable the fallback handler.\n   *\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"There is no fallback handler enabled yet\"\n   * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n   */\n\n\n  async createDisableFallbackHandlerTx(options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeDisableFallbackHandlerData(),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to enable a Safe guard.\n   *\n   * @param guardAddress - The desired guard address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid guard address provided\"\n   * @throws \"Guard provided is already enabled\"\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async createEnableGuardTx(guardAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeEnableGuardData(guardAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable a Safe guard.\n   *\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"There is no guard enabled yet\"\n   * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n   */\n\n\n  async createDisableGuardTx(options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeDisableGuardData(),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to enable a Safe module.\n   *\n   * @param moduleAddress - The desired module address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid module address provided\"\n   * @throws \"Module provided is already enabled\"\n   */\n\n\n  async createEnableModuleTx(moduleAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeEnableModuleData(moduleAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to disable a Safe module.\n   *\n   * @param moduleAddress - The desired module address\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid module address provided\"\n   * @throws \"Module provided is not enabled already\"\n   */\n\n\n  async createDisableModuleTx(moduleAddress, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeDisableModuleData(moduleAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to add an owner and optionally change the threshold.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid owner address provided\"\n   * @throws \"Address provided is already an owner\"\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createAddOwnerTx(_ref5, options) {\n    let {\n      ownerAddress,\n      threshold\n    } = _ref5;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeAddOwnerWithThresholdData(ownerAddress, threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to remove an owner and optionally change the threshold.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid owner address provided\"\n   * @throws \"Address provided is not an owner\"\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createRemoveOwnerTx(_ref6, options) {\n    let {\n      ownerAddress,\n      threshold\n    } = _ref6;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeRemoveOwnerData(ownerAddress, threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to replace an owner of the Safe with a new one.\n   *\n   * @param params - The transaction params\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Invalid new owner address provided\"\n   * @throws \"Invalid old owner address provided\"\n   * @throws \"New address provided is already an owner\"\n   * @throws \"Old address provided is not an owner\"\n   */\n\n\n  async createSwapOwnerTx(_ref7, options) {\n    let {\n      oldOwnerAddress,\n      newOwnerAddress\n    } = _ref7;\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Returns the Safe transaction to change the threshold.\n   *\n   * @param threshold - The new threshold\n   * @param options - The transaction optional properties\n   * @returns The Safe transaction ready to be signed\n   * @throws \"Threshold needs to be greater than 0\"\n   * @throws \"Threshold cannot exceed owner count\"\n   */\n\n\n  async createChangeThresholdTx(threshold, options) {\n    const safeTransactionData = {\n      to: this.getAddress(),\n      value: '0',\n      data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeChangeThresholdData(threshold),\n      ...options\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    return safeTransaction;\n  }\n  /**\n   * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction\n   *\n   * @param serviceTransactionResponse - The transaction to convert\n   * @returns The converted transaction with type SafeTransaction\n   */\n\n\n  async toSafeTransactionType(serviceTransactionResponse) {\n    var _a;\n\n    const safeTransactionData = {\n      to: serviceTransactionResponse.to,\n      value: serviceTransactionResponse.value,\n      data: serviceTransactionResponse.data || '0x',\n      operation: serviceTransactionResponse.operation,\n      safeTxGas: serviceTransactionResponse.safeTxGas,\n      baseGas: serviceTransactionResponse.baseGas,\n      gasPrice: Number(serviceTransactionResponse.gasPrice),\n      gasToken: serviceTransactionResponse.gasToken,\n      refundReceiver: serviceTransactionResponse.refundReceiver,\n      nonce: serviceTransactionResponse.nonce\n    };\n    const safeTransaction = await this.createTransaction({\n      safeTransactionData\n    });\n    (_a = serviceTransactionResponse.confirmations) === null || _a === void 0 ? void 0 : _a.map(confirmation => {\n      const signature = new SafeSignature_1.default(confirmation.owner, confirmation.signature);\n      safeTransaction.addSignature(signature);\n    });\n    return safeTransaction;\n  }\n  /**\n   * Checks if a Safe transaction can be executed successfully with no errors.\n   *\n   * @param safeTransaction - The Safe transaction to check\n   * @param options - The Safe transaction execution options. Optional\n   * @returns TRUE if the Safe transaction can be executed successfully with no errors\n   */\n\n\n  async isValidTransaction(safeTransaction, options) {\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const signedSafeTransaction = await this.copyTransaction(transaction);\n    const txHash = await this.getTransactionHash(signedSafeTransaction);\n    const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n\n    for (const owner of ownersWhoApprovedTx) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n    }\n\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (!signerAddress) {\n      throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n\n    if (owners.includes(signerAddress)) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n    }\n\n    const isTxValid = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.isValidTransaction(signedSafeTransaction, {\n      from: signerAddress,\n      ...options\n    });\n    return isTxValid;\n  }\n  /**\n   * Executes a Safe transaction.\n   *\n   * @param safeTransaction - The Safe transaction to execute\n   * @param options - The Safe transaction execution options. Optional\n   * @returns The Safe transaction response\n   * @throws \"No signer provided\"\n   * @throws \"There are X signatures missing\"\n   * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n   */\n\n\n  async executeTransaction(safeTransaction, options) {\n    let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction) ? await this.toSafeTransactionType(safeTransaction) : safeTransaction;\n    const signedSafeTransaction = await this.copyTransaction(transaction);\n    const txHash = await this.getTransactionHash(signedSafeTransaction);\n    const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n\n    for (const owner of ownersWhoApprovedTx) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n    }\n\n    const owners = await this.getOwners();\n    const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n\n    if (signerAddress && owners.includes(signerAddress)) {\n      signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n    }\n\n    const threshold = await this.getThreshold();\n\n    if (threshold > signedSafeTransaction.signatures.size) {\n      const signaturesMissing = threshold - signedSafeTransaction.signatures.size;\n      throw new Error(`There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${signaturesMissing > 1 ? 's' : ''} missing`);\n    }\n\n    const value = bignumber_1.BigNumber.from(signedSafeTransaction.data.value);\n\n    if (!value.isZero()) {\n      const balance = await this.getBalance();\n\n      if (value.gt(bignumber_1.BigNumber.from(balance))) {\n        throw new Error('Not enough Ether funds');\n      }\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n      throw new Error('Cannot specify gas and gasLimit together in transaction options');\n    }\n\n    const txResponse = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.execTransaction(signedSafeTransaction, {\n      from: signerAddress,\n      ...options\n    });\n    return txResponse;\n  }\n\n}\n\n_Safe_ethAdapter = new WeakMap(), _Safe_contractManager = new WeakMap(), _Safe_ownerManager = new WeakMap(), _Safe_moduleManager = new WeakMap(), _Safe_guardManager = new WeakMap(), _Safe_fallbackHandlerManager = new WeakMap();\nexports.default = Safe;","map":{"version":3,"sources":["../../src/Safe.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _Safe_ethAdapter, _Safe_contractManager, _Safe_ownerManager, _Safe_moduleManager, _Safe_guardManager, _Safe_fallbackHandlerManager;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bignumber_1 = require(\"@ethersproject/bignumber\");\nconst safe_core_sdk_types_1 = require(\"@safe-global/safe-core-sdk-types\");\nconst contractManager_1 = __importDefault(require(\"./managers/contractManager\"));\nconst fallbackHandlerManager_1 = __importDefault(require(\"./managers/fallbackHandlerManager\"));\nconst guardManager_1 = __importDefault(require(\"./managers/guardManager\"));\nconst moduleManager_1 = __importDefault(require(\"./managers/moduleManager\"));\nconst ownerManager_1 = __importDefault(require(\"./managers/ownerManager\"));\nconst utils_1 = require(\"./utils\");\nconst signatures_1 = require(\"./utils/signatures\");\nconst SafeSignature_1 = __importDefault(require(\"./utils/signatures/SafeSignature\"));\nconst SafeTransaction_1 = __importDefault(require(\"./utils/transactions/SafeTransaction\"));\nconst utils_2 = require(\"./utils/transactions/utils\");\nclass Safe {\n    constructor() {\n        _Safe_ethAdapter.set(this, void 0);\n        _Safe_contractManager.set(this, void 0);\n        _Safe_ownerManager.set(this, void 0);\n        _Safe_moduleManager.set(this, void 0);\n        _Safe_guardManager.set(this, void 0);\n        _Safe_fallbackHandlerManager.set(this, void 0);\n    }\n    /**\n     * Creates an instance of the Safe Core SDK.\n     * @param config - Ethers Safe configuration\n     * @returns The Safe Core SDK instance\n     * @throws \"SafeProxy contract is not deployed on the current network\"\n     * @throws \"MultiSend contract is not deployed on the current network\"\n     * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n     */\n    static async create({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {\n        const safeSdk = new Safe();\n        await safeSdk.init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks });\n        return safeSdk;\n    }\n    /**\n     * Initializes the Safe Core SDK instance.\n     * @param config - Safe configuration\n     * @throws \"Signer must be connected to a provider\"\n     * @throws \"SafeProxy contract is not deployed on the current network\"\n     * @throws \"MultiSend contract is not deployed on the current network\"\n     * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n     */\n    async init({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {\n        __classPrivateFieldSet(this, _Safe_ethAdapter, ethAdapter, \"f\");\n        __classPrivateFieldSet(this, _Safe_contractManager, await contractManager_1.default.create({\n            ethAdapter: __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n            safeAddress,\n            isL1SafeMasterCopy,\n            contractNetworks\n        }), \"f\");\n        __classPrivateFieldSet(this, _Safe_ownerManager, new ownerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n        __classPrivateFieldSet(this, _Safe_moduleManager, new moduleManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n        __classPrivateFieldSet(this, _Safe_guardManager, new guardManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n        __classPrivateFieldSet(this, _Safe_fallbackHandlerManager, new fallbackHandlerManager_1.default(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract), \"f\");\n    }\n    /**\n     * Returns a new instance of the Safe Core SDK.\n     * @param config - Connect Safe configuration\n     * @throws \"SafeProxy contract is not deployed on the current network\"\n     * @throws \"MultiSend contract is not deployed on the current network\"\n     * @throws \"MultiSendCallOnly contract is not deployed on the current network\"\n     */\n    async connect({ ethAdapter, safeAddress, isL1SafeMasterCopy, contractNetworks }) {\n        return await Safe.create({\n            ethAdapter: ethAdapter || __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"),\n            safeAddress: safeAddress || this.getAddress(),\n            isL1SafeMasterCopy: isL1SafeMasterCopy || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").isL1SafeMasterCopy,\n            contractNetworks: contractNetworks || __classPrivateFieldGet(this, _Safe_contractManager, \"f\").contractNetworks\n        });\n    }\n    /**\n     * Returns the address of the current SafeProxy contract.\n     *\n     * @returns The address of the SafeProxy contract\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getAddress();\n    }\n    /**\n     * Returns the ContractManager\n     *\n     * @returns The current ContractManager\n     * */\n    getContractManager() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\");\n    }\n    /**\n     * Returns the current EthAdapter.\n     *\n     * @returns The current EthAdapter\n     */\n    getEthAdapter() {\n        return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\");\n    }\n    /**\n     * Returns the address of the MultiSend contract.\n     *\n     * @returns The address of the MultiSend contract\n     */\n    getMultiSendAddress() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract.getAddress();\n    }\n    /**\n     * Returns the address of the MultiSendCallOnly contract.\n     *\n     * @returns The address of the MultiSendCallOnly contract\n     */\n    getMultiSendCallOnlyAddress() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract.getAddress();\n    }\n    /**\n     * Returns the Safe Master Copy contract version.\n     *\n     * @returns The Safe Master Copy contract version\n     */\n    async getContractVersion() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getVersion();\n    }\n    /**\n     * Returns the list of Safe owner accounts.\n     *\n     * @returns The list of owners\n     */\n    async getOwners() {\n        return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getOwners();\n    }\n    /**\n     * Returns the Safe nonce.\n     *\n     * @returns The Safe nonce\n     */\n    async getNonce() {\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getNonce();\n    }\n    /**\n     * Returns the Safe threshold.\n     *\n     * @returns The Safe threshold\n     */\n    async getThreshold() {\n        return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").getThreshold();\n    }\n    /**\n     * Returns the chainId of the connected network.\n     *\n     * @returns The chainId of the connected network\n     */\n    async getChainId() {\n        return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getChainId();\n    }\n    /**\n     * Returns the ETH balance of the Safe.\n     *\n     * @returns The ETH balance of the Safe\n     */\n    async getBalance() {\n        return __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getBalance(this.getAddress());\n    }\n    /**\n     * Returns the address of the FallbackHandler contract.\n     *\n     * @returns The address of the FallbackHandler contract\n     */\n    getFallbackHandler() {\n        return __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").getFallbackHandler();\n    }\n    /**\n     * Returns the enabled Safe guard or 0x address if no guards are enabled.\n     *\n     * @returns The address of the enabled Safe guard\n     * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n     */\n    async getGuard() {\n        return __classPrivateFieldGet(this, _Safe_guardManager, \"f\").getGuard();\n    }\n    /**\n     * Returns the list of addresses of all the enabled Safe modules.\n     *\n     * @returns The list of addresses of all the enabled Safe modules\n     */\n    async getModules() {\n        return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").getModules();\n    }\n    /**\n     * Checks if a specific Safe module is enabled for the current Safe.\n     *\n     * @param moduleAddress - The desired module address\n     * @returns TRUE if the module is enabled\n     */\n    async isModuleEnabled(moduleAddress) {\n        return __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").isModuleEnabled(moduleAddress);\n    }\n    /**\n     * Checks if a specific address is an owner of the current Safe.\n     *\n     * @param ownerAddress - The account address\n     * @returns TRUE if the account is an owner\n     */\n    async isOwner(ownerAddress) {\n        return __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").isOwner(ownerAddress);\n    }\n    /**\n     * Returns a Safe transaction ready to be signed by the owners.\n     *\n     * @param createTransactionProps - The createTransaction props\n     * @returns The Safe transaction\n     * @throws \"Invalid empty array of transactions\"\n     */\n    async createTransaction({ safeTransactionData, onlyCalls = false, options }) {\n        if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length === 0) {\n            throw new Error('Invalid empty array of transactions');\n        }\n        let newTransaction;\n        if ((0, utils_1.isMetaTransactionArray)(safeTransactionData) && safeTransactionData.length > 1) {\n            const multiSendContract = onlyCalls\n                ? __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendCallOnlyContract\n                : __classPrivateFieldGet(this, _Safe_contractManager, \"f\").multiSendContract;\n            const multiSendData = (0, utils_2.encodeMultiSendData)(safeTransactionData.map(utils_2.standardizeMetaTransactionData));\n            const multiSendTransaction = {\n                ...options,\n                to: multiSendContract.getAddress(),\n                value: '0',\n                data: multiSendContract.encode('multiSend', [multiSendData]),\n                operation: safe_core_sdk_types_1.OperationType.DelegateCall\n            };\n            newTransaction = multiSendTransaction;\n        }\n        else {\n            newTransaction = (0, utils_1.isMetaTransactionArray)(safeTransactionData)\n                ? { ...options, ...safeTransactionData[0] }\n                : safeTransactionData;\n        }\n        const standardizedTransaction = await (0, utils_2.standardizeSafeTransactionData)(__classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract, __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), newTransaction);\n        return new SafeTransaction_1.default(standardizedTransaction);\n    }\n    /**\n     * Returns a Safe transaction ready to be signed by the owners that invalidates the pending Safe transaction/s with a specific nonce.\n     *\n     * @param nonce - The nonce of the transaction/s that are going to be rejected\n     * @returns The Safe transaction that invalidates the pending Safe transaction/s\n     */\n    async createRejectionTransaction(nonce) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            nonce,\n            value: '0',\n            data: '0x',\n            safeTxGas: 0\n        };\n        return this.createTransaction({ safeTransactionData });\n    }\n    /**\n     * Copies a Safe transaction\n     *\n     * @param safeTransaction - The Safe transaction\n     * @returns The new Safe transaction\n     */\n    async copyTransaction(safeTransaction) {\n        const signedSafeTransaction = await this.createTransaction({\n            safeTransactionData: safeTransaction.data\n        });\n        safeTransaction.signatures.forEach((signature) => {\n            signedSafeTransaction.addSignature(signature);\n        });\n        return signedSafeTransaction;\n    }\n    /**\n     * Returns the transaction hash of a Safe transaction.\n     *\n     * @param safeTransaction - The Safe transaction\n     * @returns The transaction hash of the Safe transaction\n     */\n    async getTransactionHash(safeTransaction) {\n        const safeTransactionData = safeTransaction.data;\n        const txHash = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.getTransactionHash(safeTransactionData);\n        return txHash;\n    }\n    /**\n     * Signs a hash using the current signer account.\n     *\n     * @param hash - The hash to sign\n     * @returns The Safe signature\n     */\n    async signTransactionHash(hash) {\n        return (0, signatures_1.generateSignature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), hash);\n    }\n    /**\n     * Signs a transaction according to the EIP-712 using the current signer account.\n     *\n     * @param safeTransaction - The Safe transaction to be signed\n     * @param methodVersion - EIP-712 version. Optional\n     * @returns The Safe signature\n     */\n    async signTypedData(safeTransaction, methodVersion) {\n        const safeTransactionEIP712Args = {\n            safeAddress: this.getAddress(),\n            safeVersion: await this.getContractVersion(),\n            chainId: await this.getEthAdapter().getChainId(),\n            safeTransactionData: safeTransaction.data\n        };\n        return (0, signatures_1.generateEIP712Signature)(__classPrivateFieldGet(this, _Safe_ethAdapter, \"f\"), safeTransactionEIP712Args, methodVersion);\n    }\n    /**\n     * Adds the signature of the current signer to the Safe transaction object.\n     *\n     * @param safeTransaction - The Safe transaction to be signed\n     * @param signingMethod - Method followed to sign a transaction. Optional. Default value is \"eth_sign\"\n     * @returns The signed Safe transaction\n     * @throws \"Transactions can only be signed by Safe owners\"\n     */\n    async signTransaction(safeTransaction, signingMethod = 'eth_sign') {\n        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction)\n            ? await this.toSafeTransactionType(safeTransaction)\n            : safeTransaction;\n        const owners = await this.getOwners();\n        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n        if (!signerAddress) {\n            throw new Error('EthAdapter must be initialized with a signer to use this method');\n        }\n        const addressIsOwner = owners.find((owner) => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n        if (!addressIsOwner) {\n            throw new Error('Transactions can only be signed by Safe owners');\n        }\n        let signature;\n        if (signingMethod === 'eth_signTypedData') {\n            signature = await this.signTypedData(transaction);\n        }\n        else {\n            const txHash = await this.getTransactionHash(transaction);\n            signature = await this.signTransactionHash(txHash);\n        }\n        const signedSafeTransaction = await this.createTransaction({\n            safeTransactionData: transaction.data\n        });\n        transaction.signatures.forEach((signature) => {\n            signedSafeTransaction.addSignature(signature);\n        });\n        signedSafeTransaction.addSignature(signature);\n        return signedSafeTransaction;\n    }\n    /**\n     * Approves on-chain a hash using the current signer account.\n     *\n     * @param hash - The hash to approve\n     * @param options - The Safe transaction execution options. Optional\n     * @returns The Safe transaction response\n     * @throws \"Transaction hashes can only be approved by Safe owners\"\n     * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n     */\n    async approveTransactionHash(hash, options) {\n        const owners = await this.getOwners();\n        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n        if (!signerAddress) {\n            throw new Error('EthAdapter must be initialized with a signer to use this method');\n        }\n        const addressIsOwner = owners.find((owner) => signerAddress && (0, utils_1.sameString)(owner, signerAddress));\n        if (!addressIsOwner) {\n            throw new Error('Transaction hashes can only be approved by Safe owners');\n        }\n        if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n            throw new Error('Cannot specify gas and gasLimit together in transaction options');\n        }\n        return __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approveHash(hash, {\n            from: signerAddress,\n            ...options\n        });\n    }\n    /**\n     * Returns a list of owners who have approved a specific Safe transaction.\n     *\n     * @param txHash - The Safe transaction hash\n     * @returns The list of owners\n     */\n    async getOwnersWhoApprovedTx(txHash) {\n        const owners = await this.getOwners();\n        let ownersWhoApproved = [];\n        for (const owner of owners) {\n            const approved = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.approvedHashes(owner, txHash);\n            if (approved.gt(0)) {\n                ownersWhoApproved.push(owner);\n            }\n        }\n        return ownersWhoApproved;\n    }\n    /**\n     * Returns the Safe transaction to enable the fallback handler.\n     *\n     * @param address - The new fallback handler address\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid fallback handler address provided\"\n     * @throws \"Fallback handler provided is already enabled\"\n     * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n     */\n    async createEnableFallbackHandlerTx(fallbackHandlerAddress, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeEnableFallbackHandlerData(fallbackHandlerAddress),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to disable the fallback handler.\n     *\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"There is no fallback handler enabled yet\"\n     * @throws \"Current version of the Safe does not support the fallback handler functionality\"\n     */\n    async createDisableFallbackHandlerTx(options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_fallbackHandlerManager, \"f\").encodeDisableFallbackHandlerData(),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to enable a Safe guard.\n     *\n     * @param guardAddress - The desired guard address\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid guard address provided\"\n     * @throws \"Guard provided is already enabled\"\n     * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n     */\n    async createEnableGuardTx(guardAddress, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeEnableGuardData(guardAddress),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to disable a Safe guard.\n     *\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"There is no guard enabled yet\"\n     * @throws \"Current version of the Safe does not support Safe transaction guards functionality\"\n     */\n    async createDisableGuardTx(options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_guardManager, \"f\").encodeDisableGuardData(),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to enable a Safe module.\n     *\n     * @param moduleAddress - The desired module address\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid module address provided\"\n     * @throws \"Module provided is already enabled\"\n     */\n    async createEnableModuleTx(moduleAddress, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeEnableModuleData(moduleAddress),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to disable a Safe module.\n     *\n     * @param moduleAddress - The desired module address\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid module address provided\"\n     * @throws \"Module provided is not enabled already\"\n     */\n    async createDisableModuleTx(moduleAddress, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_moduleManager, \"f\").encodeDisableModuleData(moduleAddress),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to add an owner and optionally change the threshold.\n     *\n     * @param params - The transaction params\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid owner address provided\"\n     * @throws \"Address provided is already an owner\"\n     * @throws \"Threshold needs to be greater than 0\"\n     * @throws \"Threshold cannot exceed owner count\"\n     */\n    async createAddOwnerTx({ ownerAddress, threshold }, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeAddOwnerWithThresholdData(ownerAddress, threshold),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to remove an owner and optionally change the threshold.\n     *\n     * @param params - The transaction params\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid owner address provided\"\n     * @throws \"Address provided is not an owner\"\n     * @throws \"Threshold needs to be greater than 0\"\n     * @throws \"Threshold cannot exceed owner count\"\n     */\n    async createRemoveOwnerTx({ ownerAddress, threshold }, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeRemoveOwnerData(ownerAddress, threshold),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to replace an owner of the Safe with a new one.\n     *\n     * @param params - The transaction params\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Invalid new owner address provided\"\n     * @throws \"Invalid old owner address provided\"\n     * @throws \"New address provided is already an owner\"\n     * @throws \"Old address provided is not an owner\"\n     */\n    async createSwapOwnerTx({ oldOwnerAddress, newOwnerAddress }, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeSwapOwnerData(oldOwnerAddress, newOwnerAddress),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Returns the Safe transaction to change the threshold.\n     *\n     * @param threshold - The new threshold\n     * @param options - The transaction optional properties\n     * @returns The Safe transaction ready to be signed\n     * @throws \"Threshold needs to be greater than 0\"\n     * @throws \"Threshold cannot exceed owner count\"\n     */\n    async createChangeThresholdTx(threshold, options) {\n        const safeTransactionData = {\n            to: this.getAddress(),\n            value: '0',\n            data: await __classPrivateFieldGet(this, _Safe_ownerManager, \"f\").encodeChangeThresholdData(threshold),\n            ...options\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        return safeTransaction;\n    }\n    /**\n     * Converts a transaction from type SafeMultisigTransactionResponse to type SafeTransaction\n     *\n     * @param serviceTransactionResponse - The transaction to convert\n     * @returns The converted transaction with type SafeTransaction\n     */\n    async toSafeTransactionType(serviceTransactionResponse) {\n        var _a;\n        const safeTransactionData = {\n            to: serviceTransactionResponse.to,\n            value: serviceTransactionResponse.value,\n            data: serviceTransactionResponse.data || '0x',\n            operation: serviceTransactionResponse.operation,\n            safeTxGas: serviceTransactionResponse.safeTxGas,\n            baseGas: serviceTransactionResponse.baseGas,\n            gasPrice: Number(serviceTransactionResponse.gasPrice),\n            gasToken: serviceTransactionResponse.gasToken,\n            refundReceiver: serviceTransactionResponse.refundReceiver,\n            nonce: serviceTransactionResponse.nonce\n        };\n        const safeTransaction = await this.createTransaction({ safeTransactionData });\n        (_a = serviceTransactionResponse.confirmations) === null || _a === void 0 ? void 0 : _a.map((confirmation) => {\n            const signature = new SafeSignature_1.default(confirmation.owner, confirmation.signature);\n            safeTransaction.addSignature(signature);\n        });\n        return safeTransaction;\n    }\n    /**\n     * Checks if a Safe transaction can be executed successfully with no errors.\n     *\n     * @param safeTransaction - The Safe transaction to check\n     * @param options - The Safe transaction execution options. Optional\n     * @returns TRUE if the Safe transaction can be executed successfully with no errors\n     */\n    async isValidTransaction(safeTransaction, options) {\n        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction)\n            ? await this.toSafeTransactionType(safeTransaction)\n            : safeTransaction;\n        const signedSafeTransaction = await this.copyTransaction(transaction);\n        const txHash = await this.getTransactionHash(signedSafeTransaction);\n        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n        for (const owner of ownersWhoApprovedTx) {\n            signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n        }\n        const owners = await this.getOwners();\n        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n        if (!signerAddress) {\n            throw new Error('EthAdapter must be initialized with a signer to use this method');\n        }\n        if (owners.includes(signerAddress)) {\n            signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n        }\n        const isTxValid = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.isValidTransaction(signedSafeTransaction, {\n            from: signerAddress,\n            ...options\n        });\n        return isTxValid;\n    }\n    /**\n     * Executes a Safe transaction.\n     *\n     * @param safeTransaction - The Safe transaction to execute\n     * @param options - The Safe transaction execution options. Optional\n     * @returns The Safe transaction response\n     * @throws \"No signer provided\"\n     * @throws \"There are X signatures missing\"\n     * @throws \"Cannot specify gas and gasLimit together in transaction options\"\n     */\n    async executeTransaction(safeTransaction, options) {\n        let transaction = (0, utils_1.isSafeMultisigTransactionResponse)(safeTransaction)\n            ? await this.toSafeTransactionType(safeTransaction)\n            : safeTransaction;\n        const signedSafeTransaction = await this.copyTransaction(transaction);\n        const txHash = await this.getTransactionHash(signedSafeTransaction);\n        const ownersWhoApprovedTx = await this.getOwnersWhoApprovedTx(txHash);\n        for (const owner of ownersWhoApprovedTx) {\n            signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(owner));\n        }\n        const owners = await this.getOwners();\n        const signerAddress = await __classPrivateFieldGet(this, _Safe_ethAdapter, \"f\").getSignerAddress();\n        if (signerAddress && owners.includes(signerAddress)) {\n            signedSafeTransaction.addSignature((0, signatures_1.generatePreValidatedSignature)(signerAddress));\n        }\n        const threshold = await this.getThreshold();\n        if (threshold > signedSafeTransaction.signatures.size) {\n            const signaturesMissing = threshold - signedSafeTransaction.signatures.size;\n            throw new Error(`There ${signaturesMissing > 1 ? 'are' : 'is'} ${signaturesMissing} signature${signaturesMissing > 1 ? 's' : ''} missing`);\n        }\n        const value = bignumber_1.BigNumber.from(signedSafeTransaction.data.value);\n        if (!value.isZero()) {\n            const balance = await this.getBalance();\n            if (value.gt(bignumber_1.BigNumber.from(balance))) {\n                throw new Error('Not enough Ether funds');\n            }\n        }\n        if ((options === null || options === void 0 ? void 0 : options.gas) && (options === null || options === void 0 ? void 0 : options.gasLimit)) {\n            throw new Error('Cannot specify gas and gasLimit together in transaction options');\n        }\n        const txResponse = await __classPrivateFieldGet(this, _Safe_contractManager, \"f\").safeContract.execTransaction(signedSafeTransaction, {\n            from: signerAddress,\n            ...options\n        });\n        return txResponse;\n    }\n}\n_Safe_ethAdapter = new WeakMap(), _Safe_contractManager = new WeakMap(), _Safe_ownerManager = new WeakMap(), _Safe_moduleManager = new WeakMap(), _Safe_guardManager = new WeakMap(), _Safe_fallbackHandlerManager = new WeakMap();\nexports.default = Safe;\n//# sourceMappingURL=Safe.js.map"]},"metadata":{},"sourceType":"script"}