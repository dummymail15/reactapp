{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst SafeSignature_1 = __importDefault(require(\"./SafeSignature\"));\n\nfunction generatePreValidatedSignature(ownerAddress) {\n  const signature = '0x000000000000000000000000' + ownerAddress.slice(2) + '0000000000000000000000000000000000000000000000000000000000000000' + '01';\n  return new SafeSignature_1.default(ownerAddress, signature);\n}\n\nexports.generatePreValidatedSignature = generatePreValidatedSignature;\n\nfunction isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {\n  let hasPrefix;\n\n  try {\n    const rsvSig = {\n      r: Buffer.from(signature.slice(2, 66), 'hex'),\n      s: Buffer.from(signature.slice(66, 130), 'hex'),\n      v: parseInt(signature.slice(130, 132), 16)\n    };\n    const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);\n    const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));\n    hasPrefix = !(0, utils_1.sameString)(recoveredAddress, ownerAddress);\n  } catch (e) {\n    hasPrefix = true;\n  }\n\n  return hasPrefix;\n}\n\nexports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;\n\nconst adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {\n  const ETHEREUM_V_VALUES = [0, 1, 27, 28];\n  const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;\n  let signatureV = parseInt(signature.slice(-2), 16);\n\n  if (!ETHEREUM_V_VALUES.includes(signatureV)) {\n    throw new Error('Invalid signature');\n  }\n\n  if (signingMethod === 'eth_sign') {\n    /*\n      The Safe's expected V value for ECDSA signature is:\n      - 27 or 28\n      - 31 or 32 if the message was signed with a EIP-191 prefix. Should be calculated as ECDSA V value + 4\n      Some wallets do that, some wallets don't, V > 30 is used by contracts to differentiate between\n      prefixed and non-prefixed messages. The only way to know if the message was signed with a\n      prefix is to check if the signer address is the same as the recovered address.\n           More info:\n      https://docs.gnosis-safe.io/contracts/signatures\n    */\n    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n    }\n\n    const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);\n    const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);\n\n    if (signatureHasPrefix) {\n      signatureV += 4;\n    }\n  }\n\n  if (signingMethod === 'eth_signTypedData') {\n    // Metamask with ledger returns V=0/1 here too, we need to adjust it to be ethereum's valid value (27 or 28)\n    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n    }\n  }\n\n  signature = signature.slice(0, -2) + signatureV.toString(16);\n  return signature;\n};\n\nexports.adjustVInSignature = adjustVInSignature;\n\nasync function generateSignature(ethAdapter, hash) {\n  const signerAddress = await ethAdapter.getSignerAddress();\n\n  if (!signerAddress) {\n    throw new Error('EthAdapter must be initialized with a signer to use this method');\n  }\n\n  let signature = await ethAdapter.signMessage(hash);\n  signature = (0, exports.adjustVInSignature)('eth_sign', signature, hash, signerAddress);\n  return new SafeSignature_1.default(signerAddress, signature);\n}\n\nexports.generateSignature = generateSignature;\n\nasync function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {\n  const signerAddress = await ethAdapter.getSignerAddress();\n\n  if (!signerAddress) {\n    throw new Error('EthAdapter must be initialized with a signer to use this method');\n  }\n\n  let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);\n  signature = (0, exports.adjustVInSignature)('eth_signTypedData', signature);\n  return new SafeSignature_1.default(signerAddress, signature);\n}\n\nexports.generateEIP712Signature = generateEIP712Signature;","map":{"version":3,"sources":["../../../../src/utils/signatures/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateEIP712Signature = exports.generateSignature = exports.adjustVInSignature = exports.isTxHashSignedWithPrefix = exports.generatePreValidatedSignature = void 0;\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst utils_1 = require(\"../../utils\");\nconst SafeSignature_1 = __importDefault(require(\"./SafeSignature\"));\nfunction generatePreValidatedSignature(ownerAddress) {\n    const signature = '0x000000000000000000000000' +\n        ownerAddress.slice(2) +\n        '0000000000000000000000000000000000000000000000000000000000000000' +\n        '01';\n    return new SafeSignature_1.default(ownerAddress, signature);\n}\nexports.generatePreValidatedSignature = generatePreValidatedSignature;\nfunction isTxHashSignedWithPrefix(txHash, signature, ownerAddress) {\n    let hasPrefix;\n    try {\n        const rsvSig = {\n            r: Buffer.from(signature.slice(2, 66), 'hex'),\n            s: Buffer.from(signature.slice(66, 130), 'hex'),\n            v: parseInt(signature.slice(130, 132), 16)\n        };\n        const recoveredData = (0, ethereumjs_util_1.ecrecover)(Buffer.from(txHash.slice(2), 'hex'), rsvSig.v, rsvSig.r, rsvSig.s);\n        const recoveredAddress = (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)(recoveredData));\n        hasPrefix = !(0, utils_1.sameString)(recoveredAddress, ownerAddress);\n    }\n    catch (e) {\n        hasPrefix = true;\n    }\n    return hasPrefix;\n}\nexports.isTxHashSignedWithPrefix = isTxHashSignedWithPrefix;\nconst adjustVInSignature = (signingMethod, signature, safeTxHash, signerAddress) => {\n    const ETHEREUM_V_VALUES = [0, 1, 27, 28];\n    const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;\n    let signatureV = parseInt(signature.slice(-2), 16);\n    if (!ETHEREUM_V_VALUES.includes(signatureV)) {\n        throw new Error('Invalid signature');\n    }\n    if (signingMethod === 'eth_sign') {\n        /*\n          The Safe's expected V value for ECDSA signature is:\n          - 27 or 28\n          - 31 or 32 if the message was signed with a EIP-191 prefix. Should be calculated as ECDSA V value + 4\n          Some wallets do that, some wallets don't, V > 30 is used by contracts to differentiate between\n          prefixed and non-prefixed messages. The only way to know if the message was signed with a\n          prefix is to check if the signer address is the same as the recovered address.\n    \n          More info:\n          https://docs.gnosis-safe.io/contracts/signatures\n        */\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n        }\n        const adjustedSignature = signature.slice(0, -2) + signatureV.toString(16);\n        const signatureHasPrefix = isTxHashSignedWithPrefix(safeTxHash, adjustedSignature, signerAddress);\n        if (signatureHasPrefix) {\n            signatureV += 4;\n        }\n    }\n    if (signingMethod === 'eth_signTypedData') {\n        // Metamask with ledger returns V=0/1 here too, we need to adjust it to be ethereum's valid value (27 or 28)\n        if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {\n            signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;\n        }\n    }\n    signature = signature.slice(0, -2) + signatureV.toString(16);\n    return signature;\n};\nexports.adjustVInSignature = adjustVInSignature;\nasync function generateSignature(ethAdapter, hash) {\n    const signerAddress = await ethAdapter.getSignerAddress();\n    if (!signerAddress) {\n        throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n    let signature = await ethAdapter.signMessage(hash);\n    signature = (0, exports.adjustVInSignature)('eth_sign', signature, hash, signerAddress);\n    return new SafeSignature_1.default(signerAddress, signature);\n}\nexports.generateSignature = generateSignature;\nasync function generateEIP712Signature(ethAdapter, safeTransactionEIP712Args, methodVersion) {\n    const signerAddress = await ethAdapter.getSignerAddress();\n    if (!signerAddress) {\n        throw new Error('EthAdapter must be initialized with a signer to use this method');\n    }\n    let signature = await ethAdapter.signTypedData(safeTransactionEIP712Args, methodVersion);\n    signature = (0, exports.adjustVInSignature)('eth_signTypedData', signature);\n    return new SafeSignature_1.default(signerAddress, signature);\n}\nexports.generateEIP712Signature = generateEIP712Signature;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}