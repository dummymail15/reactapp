{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"../../utils\");\n\nclass SignMessageLibEthersContract {\n  constructor(contract) {\n    this.contract = contract;\n\n    this.encode = (methodName, params) => {\n      return this.contract.interface.encodeFunctionData(methodName, params);\n    };\n  }\n\n  getAddress() {\n    return this.contract.address;\n  }\n\n  async signMessage(data, options) {\n    if (options && !options.gasLimit) {\n      options.gasLimit = await this.estimateGas('signMessage', [data], { ...options\n      });\n    }\n\n    const txResponse = await this.contract.signMessage(data, options);\n    return (0, utils_1.toTxResult)(txResponse, options);\n  }\n\n  async getMessageHash(message) {\n    return this.contract.getMessageHash(message);\n  }\n\n  async estimateGas(methodName, params, options) {\n    return (await this.contract.estimateGas[methodName](...params, options)).toNumber();\n  }\n\n}\n\nexports.default = SignMessageLibEthersContract;","map":{"version":3,"sources":["../../../../src/contracts/SignMessageLib/SignMessageLibEthersContract.ts"],"names":[],"mappings":";;;;;;AAMA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAe,4BAAf,CAA2C;AACzC,EAAA,WAAA,CAAmB,QAAnB,EAAkD;AAA/B,SAAA,QAAA,GAAA,QAAA;;AAqBnB,SAAA,MAAA,GAAgE,CAC9D,UAD8D,EAE9D,MAF8D,KAGpD;AACV,aAAO,KAAK,QAAL,CAAc,SAAd,CAAwB,kBAAxB,CAA2C,UAA3C,EAAuD,MAAvD,CAAP;AACD,KALD;AArBsD;;AAEtD,EAAA,UAAU,GAAA;AACR,WAAO,KAAK,QAAL,CAAc,OAArB;AACD;;AAEgB,QAAX,WAAW,CACf,IADe,EAEf,OAFe,EAEmB;AAElC,QAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAxB,EAAkC;AAChC,MAAA,OAAO,CAAC,QAAR,GAAmB,MAAM,KAAK,WAAL,CAAiB,aAAjB,EAAgC,CAAC,IAAD,CAAhC,EAAwC,EAAE,GAAG;AAAL,OAAxC,CAAzB;AACD;;AACD,UAAM,UAAU,GAAG,MAAM,KAAK,QAAL,CAAc,WAAd,CAA0B,IAA1B,EAAgC,OAAhC,CAAzB;AACA,WAAO,CAAA,GAAA,OAAA,CAAA,UAAA,EAAW,UAAX,EAAuB,OAAvB,CAAP;AACD;;AAEmB,QAAd,cAAc,CAAC,OAAD,EAAgB;AAClC,WAAO,KAAK,QAAL,CAAc,cAAd,CAA6B,OAA7B,CAAP;AACD;;AASgB,QAAX,WAAW,CACf,UADe,EAEf,MAFe,EAGf,OAHe,EAGkB;AAEjC,WAAO,CAAC,MAAO,KAAK,QAAL,CAAc,WAAd,CAAkC,UAAlC,EAA8C,GAAG,MAAjD,EAAyD,OAAzD,CAAR,EAA2E,QAA3E,EAAP;AACD;;AAnCwC;;AAsC3C,OAAA,CAAA,OAAA,GAAe,4BAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../../utils\");\nclass SignMessageLibEthersContract {\n    constructor(contract) {\n        this.contract = contract;\n        this.encode = (methodName, params) => {\n            return this.contract.interface.encodeFunctionData(methodName, params);\n        };\n    }\n    getAddress() {\n        return this.contract.address;\n    }\n    async signMessage(data, options) {\n        if (options && !options.gasLimit) {\n            options.gasLimit = await this.estimateGas('signMessage', [data], { ...options });\n        }\n        const txResponse = await this.contract.signMessage(data, options);\n        return (0, utils_1.toTxResult)(txResponse, options);\n    }\n    async getMessageHash(message) {\n        return this.contract.getMessageHash(message);\n    }\n    async estimateGas(methodName, params, options) {\n        return (await this.contract.estimateGas[methodName](...params, options)).toNumber();\n    }\n}\nexports.default = SignMessageLibEthersContract;\n//# sourceMappingURL=SignMessageLibEthersContract.js.map"]},"metadata":{},"sourceType":"script"}